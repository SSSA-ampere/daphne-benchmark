#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *points2image_ocl_krnl =
"// points2image OpenCL kernel\n"
"\n"
"// Structs must be known to the device\n"
"//#define MAX_NUM_WORKITEMS 32\n"
"\n"
"// See datatypes.h\n"
"typedef struct Mat44 {\n"
"  double data[4][4];\n"
"} Mat44;\n"
"\n"
"typedef struct Mat33 {\n"
"  double data[3][3];\n"
"} Mat33;\n"
"\n"
"typedef struct Mat13 {\n"
"  double data[3];\n"
"} Mat13;\n"
"\n"
"typedef struct Vec5 {\n"
"  double data[5];\n"
"} Vec5;\n"
"\n"
"typedef struct Point2d {\n"
"  double x;\n"
"  double y;\n"
"} Point2d;\n"
"\n"
"typedef struct ImageSize {\n"
"  int width;\n"
"  int height;\n"
"} ImageSize;\n"
"\n"
"/*\n"
"typedef struct PointCloud2 {\n"
"  int    height;\n"
"  int    width;\n"
"  int    point_step;\n"
"  float* data;\n"
"} PointCloud2;\n"
"\n"
"typedef struct PointsImage {\n"
"  // arrays of size image_heigt*image_width\n"
"  float* intensity;\n"
"  float* distance;\n"
"  float* min_height;\n"
"  float* max_height;\n"
"  int max_y;\n"
"  int min_y;\n"
"  int image_height;\n"
"  int image_width;\n"
"} PointsImage;\n"
"*/\n"
"\n"
"//#define PRINT_KERNEL\n"
"//#define PRINT_KERNEL_CRITICAL\n"
"//#define IT_NUMBER 45285\n"
"__kernel\n"
"void\n"
"//__attribute__ ((reqd_work_group_size(MAX_NUM_WORKITEMS,1,1)))\n"
"pointcloud2_to_image(\n"
"			  //__global const PointCloud2 pointcloud2,\n"
"					 int          pointcloud2_height,\n"
"				         int          pointcloud2_width,\n"
"					 int          pointcloud2_point_step,\n"
"			  __global const float*  restrict	pointcloud2_data,\n"
"                          					Mat44     cameraExtrinsicMat,\n"
"                          					Mat33     cameraMat,\n"
"			 					Vec5      distCoeff,\n"
"                          					ImageSize imageSize,\n"
"\n"
"			  // OpenCL: return data goes through global mem\n"
"			  //__global     PointsImage*  msg\n"
"			  	//__global       float*  restrict	msg_intensity,\n"
"			  	//__global       float*  restrict       msg_distance,\n"
"			  	//__global       float*  restrict       msg_min_height,\n"
"		          	//__global       float*  restrict       msg_max_height,\n"
"			  	//__global       int*    restrict       msg_scalars,\n"
"\n"
"			  // Global storage for serial in-order execution part\n"
"			  __global       int*    restrict       Glob_pids,\n"
"			  __global       int*    restrict       Glob_enable_pids,\n"
"			  __global       /*double**/ float* restrict	Glob_pointdata2,\n"
"			  __global       /*double**/ float* restrict   	Glob_intensity,\n"
"			  __global       int*    restrict      	Glob_py,\n"
"			  __global       float*  restrict      	Glob_fp_2\n"
"			)\n"
"{\n"
"	// Getting width and heights\n"
"	const int w          = imageSize.width;\n"
"        const int h          = imageSize.height;\n"
"	const int pc2_width  = pointcloud2_width;\n"
"	const int pc2_height = pointcloud2_height;\n"
"	const int pc2_pstep  = pointcloud2_point_step;\n"
"/*\n"
"        // Initializing msg in global memory\n"
"	// Note single-precision float notation 0.0f\n"
"	for (unsigned int cnt = get_global_id(0);\n"
"			  cnt < w*h;\n"
"			  cnt += get_global_size(0)){\n"
"		msg_distance [cnt] = 0.0f;\n"
"	}\n"
"*/\n"
"\n"
"	#if 0 //defined (PRINT_KERNEL)\n"
"	// https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/workItemFunctions.html\n"
"	//printf(\"krnl: dimensions: %u\\n\", get_work_dim());	// =1\n"
"	//printf(\"krnl: global_size: %u\\n\", get_global_size(0));\n"
"        //printf(\"krnl: wi-global-id: %u\\n\", get_global_id(0));\n"
"	//printf(\"krnl: local_size: %u\\n\", get_local_size(0));\n"
"        //printf(\"krnl: wi-local-id: %u\\n\", get_local_id(0));\n"
"        //printf(\"krnl: num-groups: %u\\n\", get_num_groups(0));\n"
"	//printf(\"krnl: group-id: %u\\n\", get_group_id(0));\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		printf(\"\\lid: %u | w : %i | h: %i | pc2_width : %i | pc2_height : %i | pc2_pstep: % i\\n\", \n"
"			get_local_id(0), w, h, pc2_width, pc2_height, pc2_pstep);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"// As suggested by CodePlay for 0.3.2\n"
"// Replacing __local by private + removing barrier\n"
"#if 0\n"
"        __local Mat33 invR;\n"
"	__local Mat13 invT;\n"
"	// invR= cameraExtrinsicMat(cv::Rect(0,0,3,3)).t();\n"
"	// row = get_local_id(0), if get_local_id(0) <3\n"
"	if (get_local_id(0) < 3) {\n"
"		for (int col = 0; col < 3; col++) {\n"
"		    invR.data[get_local_id(0)][col] = cameraExtrinsicMat.data[col][get_local_id(0)];\n"
"		}\n"
"\n"
"		// row = get_local_id(0), if get_local_id(0) <3\n"
"		invT.data[get_local_id(0)] = 0.0;\n"
"\n"
"		for (int col = 0; col < 3; col++) {\n"
"		    //invT = -invR*(cameraExtrinsicMat(cv::Rect(3,0,1,3)));\n"
"		    invT.data[get_local_id(0)] -= invR.data[get_local_id(0)][col] * cameraExtrinsicMat.data[col][3];\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"\n"
"#if 1\n"
"      Mat33 invR;\n"
"      Mat13 invT;\n"
"      // invR= cameraExtrinsicMat(cv::Rect(0,0,3,3)).t();\n"
"      // row = get_local_id(0), if get_local_id(0) <3\n"
"      for (int row = 0; row < 3; row++) {\n"
"        for (int col = 0; col < 3; col++) {\n"
"          invR.data[row][col] = cameraExtrinsicMat.data[col][row];\n"
"        }\n"
"\n"
"        // row = get_local_id(0), if get_local_id(0) <3\n"
"        invT.data[row] = 0.0;\n"
"\n"
"        for (int col = 0; col < 3; col++) {\n"
"          // invT = -invR*(cameraExtrinsicMat(cv::Rect(3,0,1,3)));\n"
"          invT.data[row] -= invR.data[row][col] * cameraExtrinsicMat.data[col][3];\n"
"        }\n"
"      }\n"
"      /* barrier(CLK_LOCAL_MEM_FENCE); */\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"        #if 0 //defined (PRINT_KERNEL)\n"
"	if (get_local_id(0) == 0) {\n"
"	        printf(\"(Mat33) invR: \\n\");\n"
"        	for (unsigned int idx = 0; idx < 3; idx ++) {\n"
"	        	for (unsigned int idy = 0; idy < 3; idy ++) {\n"
"        	        	printf(\"%u | %u | %f \\n\", idx, idy, invR.data[idx][idy]);\n"
"                	}\n"
"	        }\n"
"        	printf(\"\\n\");\n"
"\n"
"	        printf(\"(Mat13) invT: \\n\");\n"
"        	for (unsigned int idx = 0; idx < 3; idx ++) {\n"
"        		printf(\"%u | %f \\n\",  idx, invT.data[idx]);\n"
"	        }\n"
"        	printf(\"\\n\");\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"        #endif\n"
"\n"
"\n"
"\n"
"\n"
"	// Defining a global const pointer\n"
"        __global const float* cp = (__global const float *)(pointcloud2_data);\n"
"\n"
"	// Main loop. Inner loop can run in parallel (outer bound=1)\n"
"#if 0\n"
"	for (/*unsigned*/ int y = 0; y < pc2_height; ++y) {\n"
"#endif\n"
"	const int y = 0;\n"
"		/*unsigned*/ int x = (int)get_global_id(0);\n"
"		if (x < pc2_width) {\n"
"			int offset1 = (x + y*pc2_width) * pc2_pstep;\n"
"\n"
"	                //__global float* fp = (__global const float *)(cp + offset1);\n"
"			float fp[5];\n"
"			for (/*unsigned*/ int k = 0; k < 5; k ++) {\n"
"				fp[k] = cp [offset1/4 + k];\n"
"			}\n"
"			/*\n"
"			double intensity = convert_double(fp[4]);\n"
"			*/\n"
"			float intensity = fp[4];\n"
"\n"
"			#if 0 //defined (PRINT_KERNEL)\n"
"			//printf(\"%-15s %10u\\n\", \"inner loop id (x) : \", x);\n"
"			printf(\"%-15s %15u\\n\", \"offset1 : \", (x + y*pointcloud2.width) * pointcloud2.point_step);\n"
"			//printf(\"%s %15f\\n\", \"intensity: \", intensity);\n"
"\n"
"			#endif\n"
"\n"
"			Mat13 point2;\n"
"			/*\n"
"                        point2.data[0] = convert_double(fp[0]);\n"
"                        point2.data[1] = convert_double(fp[1]);\n"
"                        point2.data[2] = convert_double(fp[2]);\n"
"			*/\n"
"                        point2.data[0] = fp[0];\n"
"                        point2.data[1] = fp[1];\n"
"                        point2.data[2] = fp[2];\n"
"\n"
"                        Mat13 point;\n"
"                        //point = point * invR.t() + invT.t();\n"
"			for (int row = 0; row < 3; row++) {\n"
"			  point.data[row] = invT.data[row];\n"
"			  for (int col = 0; col < 3; col++) \n"
"			    point.data[row] += point2.data[col] * invR.data[row][col];\n"
"			}\n"
"\n"
"                        //if (point.data[2] <= 2.5) {\n"
"                        //        continue;\n"
"                        //}\n"
"                        if (point.data[2] <= 2.5) {\n"
"			    	Glob_enable_pids [x] = 0; // disabled\n"
"                        }\n"
"\n"
"			else {\n"
"		                double tmpx = point.data[0] / point.data[2];\n"
"		                double tmpy = point.data[1] / point.data[2];\n"
"		                double r2 = tmpx * tmpx + tmpy * tmpy;\n"
"		                double tmpdist = 1 + distCoeff.data[0] * r2\n"
"		                        + distCoeff.data[1] * r2 * r2\n"
"		                        + distCoeff.data[4] * r2 * r2 * r2;\n"
"\n"
"		                double imgx = tmpx * tmpdist\n"
"		                        	+ 2 * distCoeff.data[2] * tmpx * tmpy\n"
"			                        + distCoeff.data[3] * (r2 + 2 * tmpx * tmpx);\n"
"\n"
"		                double imgy = tmpy * tmpdist\n"
"			                        + distCoeff.data[2] * (r2 + 2 * tmpy * tmpy)\n"
"			                        + 2 * distCoeff.data[3] * tmpx * tmpy;\n"
"\n"
"\n"
"		                int px = (int)(cameraMat.data[0][0] * imgx + cameraMat.data[0][2] + 0.5);\n"
"		                int py = (int)(cameraMat.data[1][1] * imgy + cameraMat.data[1][2] + 0.5);\n"
"\n"
"				if( (0 <= px) && (px < w) && (0 <= py) && (py < h) ) {\n"
"					int pid = py * w + px;\n"
"					Glob_pids	 [x] = pid;\n"
"				    	Glob_enable_pids [x] = 1; // enabled\n"
"					Glob_pointdata2  [x] = point.data[2];\n"
"					Glob_intensity   [x] = intensity;\n"
"					Glob_py          [x] = py;\n"
"					Glob_fp_2        [x] = fp[2];\n"
"				}\n"
"				else {\n"
"				    	Glob_enable_pids [x] = 0; // disabled\n"
"				} // End: if(0 <= px && px < w && 0 <= py && py < h) {\n"
"			} // End: if (point.data[2] <= 2.5) {\n"
"               } // End: for (/*unsigned*/ int x = 0; x < pc2_width; ++x) {\n"
"#if 0\n"
"        } // End: for (/*unsigned*/ int y = 0; y < pc2_height; ++y) {\n"
"#endif\n"
"}\n"
"\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *points2image_ocl_krnl =
"// points2image OpenCL kernel\n"
"\n"
"// Structs must be known to the device\n"
"//#define MAX_NUM_WORKITEMS 32\n"
"\n"
"// See datatypes.h\n"
"typedef struct Mat44 {\n"
"  double data[4][4];\n"
"} Mat44;\n"
"\n"
"typedef struct Mat33 {\n"
"  double data[3][3];\n"
"} Mat33;\n"
"\n"
"typedef struct Mat13 {\n"
"  double data[3];\n"
"} Mat13;\n"
"\n"
"typedef struct Vec5 {\n"
"  double data[5];\n"
"} Vec5;\n"
"\n"
"typedef struct Point2d {\n"
"  double x;\n"
"  double y;\n"
"} Point2d;\n"
"\n"
"typedef struct ImageSize {\n"
"  int width;\n"
"  int height;\n"
"} ImageSize;\n"
"\n"
"/*\n"
"typedef struct PointCloud2 {\n"
"  int    height;\n"
"  int    width;\n"
"  int    point_step;\n"
"  float* data;\n"
"} PointCloud2;\n"
"\n"
"typedef struct PointsImage {\n"
"  // arrays of size image_heigt*image_width\n"
"  float* intensity;\n"
"  float* distance;\n"
"  float* min_height;\n"
"  float* max_height;\n"
"  int max_y;\n"
"  int min_y;\n"
"  int image_height;\n"
"  int image_width;\n"
"} PointsImage;\n"
"*/\n"
"\n"
"//#define PRINT_KERNEL\n"
"//#define PRINT_KERNEL_CRITICAL\n"
"//#define IT_NUMBER 45285\n"
"__kernel\n"
"void\n"
"//__attribute__ ((reqd_work_group_size(MAX_NUM_WORKITEMS,1,1)))\n"
"pointcloud2_to_image(\n"
"			  //__global const PointCloud2 pointcloud2,\n"
"					 int          pointcloud2_height,\n"
"				         int          pointcloud2_width,\n"
"					 int          pointcloud2_point_step,\n"
"			  __global const float*  restrict	pointcloud2_data,\n"
"                          					Mat44     cameraExtrinsicMat,\n"
"                          					Mat33     cameraMat,\n"
"			 					Vec5      distCoeff,\n"
"                          					ImageSize imageSize,\n"
"\n"
"			  // OpenCL: return data goes through global mem\n"
"			  //__global     PointsImage*  msg\n"
"			  	//__global       float*  restrict	msg_intensity,\n"
"			  	//__global       float*  restrict       msg_distance,\n"
"			  	//__global       float*  restrict       msg_min_height,\n"
"		          	//__global       float*  restrict       msg_max_height,\n"
"			  	//__global       int*    restrict       msg_scalars,\n"
"\n"
"			  // Global storage for serial in-order execution part\n"
"			  __global       int*    restrict       Glob_pids,\n"
"			  __global       int*    restrict       Glob_enable_pids,\n"
"			  __global       /*double**/ float* restrict	Glob_pointdata2,\n"
"			  __global       /*double**/ float* restrict   	Glob_intensity,\n"
"			  __global       int*    restrict      	Glob_py,\n"
"			  __global       float*  restrict      	Glob_fp_2\n"
"			)\n"
"{\n"
"	// Getting width and heights\n"
"	const int w          = imageSize.width;\n"
"        const int h          = imageSize.height;\n"
"	const int pc2_width  = pointcloud2_width;\n"
"	const int pc2_height = pointcloud2_height;\n"
"	const int pc2_pstep  = pointcloud2_point_step;\n"
"/*\n"
"        // Initializing msg in global memory\n"
"	// Note single-precision float notation 0.0f\n"
"	for (unsigned int cnt = get_global_id(0);\n"
"			  cnt < w*h;\n"
"			  cnt += get_global_size(0)){\n"
"		msg_distance [cnt] = 0.0f;\n"
"	}\n"
"*/\n"
"\n"
"	#if 0 //defined (PRINT_KERNEL)\n"
"	// https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/workItemFunctions.html\n"
"	//printf(\"krnl: dimensions: %u\\n\", get_work_dim());	// =1\n"
"	//printf(\"krnl: global_size: %u\\n\", get_global_size(0));\n"
"        //printf(\"krnl: wi-global-id: %u\\n\", get_global_id(0));\n"
"	//printf(\"krnl: local_size: %u\\n\", get_local_size(0));\n"
"        //printf(\"krnl: wi-local-id: %u\\n\", get_local_id(0));\n"
"        //printf(\"krnl: num-groups: %u\\n\", get_num_groups(0));\n"
"	//printf(\"krnl: group-id: %u\\n\", get_group_id(0));\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		printf(\"\\lid: %u | w : %i | h: %i | pc2_width : %i | pc2_height : %i | pc2_pstep: % i\\n\", \n"
"			get_local_id(0), w, h, pc2_width, pc2_height, pc2_pstep);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"// As suggested by CodePlay for 0.3.2\n"
"// Replacing __local by private + removing barrier\n"
"#if 0\n"
"        __local Mat33 invR;\n"
"	__local Mat13 invT;\n"
"	// invR= cameraExtrinsicMat(cv::Rect(0,0,3,3)).t();\n"
"	// row = get_local_id(0), if get_local_id(0) <3\n"
"	if (get_local_id(0) < 3) {\n"
"		for (int col = 0; col < 3; col++) {\n"
"		    invR.data[get_local_id(0)][col] = cameraExtrinsicMat.data[col][get_local_id(0)];\n"
"		}\n"
"\n"
"		// row = get_local_id(0), if get_local_id(0) <3\n"
"		invT.data[get_local_id(0)] = 0.0;\n"
"\n"
"		for (int col = 0; col < 3; col++) {\n"
"		    //invT = -invR*(cameraExtrinsicMat(cv::Rect(3,0,1,3)));\n"
"		    invT.data[get_local_id(0)] -= invR.data[get_local_id(0)][col] * cameraExtrinsicMat.data[col][3];\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"\n"
"#if 1\n"
"      Mat33 invR;\n"
"      Mat13 invT;\n"
"      // invR= cameraExtrinsicMat(cv::Rect(0,0,3,3)).t();\n"
"      // row = get_local_id(0), if get_local_id(0) <3\n"
"      for (int row = 0; row < 3; row++) {\n"
"        for (int col = 0; col < 3; col++) {\n"
"          invR.data[row][col] = cameraExtrinsicMat.data[col][row];\n"
"        }\n"
"\n"
"        // row = get_local_id(0), if get_local_id(0) <3\n"
"        invT.data[row] = 0.0;\n"
"\n"
"        for (int col = 0; col < 3; col++) {\n"
"          // invT = -invR*(cameraExtrinsicMat(cv::Rect(3,0,1,3)));\n"
"          invT.data[row] -= invR.data[row][col] * cameraExtrinsicMat.data[col][3];\n"
"        }\n"
"      }\n"
"      /* barrier(CLK_LOCAL_MEM_FENCE); */\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"        #if 0 //defined (PRINT_KERNEL)\n"
"	if (get_local_id(0) == 0) {\n"
"	        printf(\"(Mat33) invR: \\n\");\n"
"        	for (unsigned int idx = 0; idx < 3; idx ++) {\n"
"	        	for (unsigned int idy = 0; idy < 3; idy ++) {\n"
"        	        	printf(\"%u | %u | %f \\n\", idx, idy, invR.data[idx][idy]);\n"
"                	}\n"
"	        }\n"
"        	printf(\"\\n\");\n"
"\n"
"	        printf(\"(Mat13) invT: \\n\");\n"
"        	for (unsigned int idx = 0; idx < 3; idx ++) {\n"
"        		printf(\"%u | %f \\n\",  idx, invT.data[idx]);\n"
"	        }\n"
"        	printf(\"\\n\");\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"        #endif\n"
"\n"
"\n"
"\n"
"\n"
"	// Defining a global const pointer\n"
"        __global const float* cp = (__global const float *)(pointcloud2_data);\n"
"\n"
"	// Main loop. Inner loop can run in parallel (outer bound=1)\n"
"#if 0\n"
"	for (/*unsigned*/ int y = 0; y < pc2_height; ++y) {\n"
"#endif\n"
"	const int y = 0;\n"
"		/*unsigned*/ int x = (int)get_global_id(0);\n"
"		if (x < pc2_width) {\n"
"			int offset1 = (x + y*pc2_width) * pc2_pstep;\n"
"\n"
"	                //__global float* fp = (__global const float *)(cp + offset1);\n"
"			float fp[5];\n"
"			for (/*unsigned*/ int k = 0; k < 5; k ++) {\n"
"				fp[k] = cp [offset1/4 + k];\n"
"			}\n"
"			/*\n"
"			double intensity = convert_double(fp[4]);\n"
"			*/\n"
"			float intensity = fp[4];\n"
"\n"
"			#if 0 //defined (PRINT_KERNEL)\n"
"			//printf(\"%-15s %10u\\n\", \"inner loop id (x) : \", x);\n"
"			printf(\"%-15s %15u\\n\", \"offset1 : \", (x + y*pointcloud2.width) * pointcloud2.point_step);\n"
"			//printf(\"%s %15f\\n\", \"intensity: \", intensity);\n"
"\n"
"			#endif\n"
"\n"
"			Mat13 point2;\n"
"			/*\n"
"                        point2.data[0] = convert_double(fp[0]);\n"
"                        point2.data[1] = convert_double(fp[1]);\n"
"                        point2.data[2] = convert_double(fp[2]);\n"
"			*/\n"
"                        point2.data[0] = fp[0];\n"
"                        point2.data[1] = fp[1];\n"
"                        point2.data[2] = fp[2];\n"
"\n"
"                        Mat13 point;\n"
"                        //point = point * invR.t() + invT.t();\n"
"			for (int row = 0; row < 3; row++) {\n"
"			  point.data[row] = invT.data[row];\n"
"			  for (int col = 0; col < 3; col++) \n"
"			    point.data[row] += point2.data[col] * invR.data[row][col];\n"
"			}\n"
"\n"
"                        //if (point.data[2] <= 2.5) {\n"
"                        //        continue;\n"
"                        //}\n"
"                        if (point.data[2] <= 2.5) {\n"
"			    	Glob_enable_pids [x] = 0; // disabled\n"
"                        }\n"
"\n"
"			else {\n"
"		                double tmpx = point.data[0] / point.data[2];\n"
"		                double tmpy = point.data[1] / point.data[2];\n"
"		                double r2 = tmpx * tmpx + tmpy * tmpy;\n"
"		                double tmpdist = 1 + distCoeff.data[0] * r2\n"
"		                        + distCoeff.data[1] * r2 * r2\n"
"		                        + distCoeff.data[4] * r2 * r2 * r2;\n"
"\n"
"		                double imgx = tmpx * tmpdist\n"
"		                        	+ 2 * distCoeff.data[2] * tmpx * tmpy\n"
"			                        + distCoeff.data[3] * (r2 + 2 * tmpx * tmpx);\n"
"\n"
"		                double imgy = tmpy * tmpdist\n"
"			                        + distCoeff.data[2] * (r2 + 2 * tmpy * tmpy)\n"
"			                        + 2 * distCoeff.data[3] * tmpx * tmpy;\n"
"\n"
"\n"
"		                int px = (int)(cameraMat.data[0][0] * imgx + cameraMat.data[0][2] + 0.5);\n"
"		                int py = (int)(cameraMat.data[1][1] * imgy + cameraMat.data[1][2] + 0.5);\n"
"\n"
"				if( (0 <= px) && (px < w) && (0 <= py) && (py < h) ) {\n"
"					int pid = py * w + px;\n"
"					Glob_pids	 [x] = pid;\n"
"				    	Glob_enable_pids [x] = 1; // enabled\n"
"					Glob_pointdata2  [x] = point.data[2];\n"
"					Glob_intensity   [x] = intensity;\n"
"					Glob_py          [x] = py;\n"
"					Glob_fp_2        [x] = fp[2];\n"
"				}\n"
"				else {\n"
"				    	Glob_enable_pids [x] = 0; // disabled\n"
"				} // End: if(0 <= px && px < w && 0 <= py && py < h) {\n"
"			} // End: if (point.data[2] <= 2.5) {\n"
"               } // End: for (/*unsigned*/ int x = 0; x < pc2_width; ++x) {\n"
"#if 0\n"
"        } // End: for (/*unsigned*/ int y = 0; y < pc2_height; ++y) {\n"
"#endif\n"
"}\n"
"\n"
;
#endif // End of STRINGIFY_H
