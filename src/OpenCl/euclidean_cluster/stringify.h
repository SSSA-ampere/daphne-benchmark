#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *initRadiusSearch_ocl_krnl =
"\n"
"// Copied from euclidean_cluster/datatypes.h\n"
"\n"
"// just a 3D point (in pcl PointXYZ)\n"
"typedef struct  {\n"
"    float x,y,z;\n"
"} Point;\n"
"\n"
"\n"
"/**\n"
"   Precomputes all distances and stores the results in sqr_distances.\n"
"   Due to symmetry of the distance function (a to b as far apart as b to a),\n"
"   only one is stored.\n"
"   Size of the aray is (N*(N-1))/2.\n"
"   Distance of point i to point j (0..N-1) is stored at index:\n"
"       i == j?  nothing stored, distance is 0\n"
"       i  > j?  nothing stored, distance is equal to j, i\n"
"       j <  i?  distance is stored at:  (((i-1) * i)/2) + j\n"
"       To save computations, only the squared distance is computed\n"
"   (sufficient for comparison, does not require square root)\n"
"   and it is only stored wether it is smaller than a given radius or not\n"
"*/\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initRadiusSearch(__global const Point* restrict points,\n"
"		 __global bool*        restrict sqr_distances,\n"
"                 int    number_points, \n"
"                 #if defined (DOUBLE_FP)\n"
"                 double radius_sqr\n"
"                 #else\n"
"                 float radius_sqr\n"
"                 #endif\n"
")\n"
"{\n"
"  int n = number_points;\n"
"\n"
"/*\n"
"  #if defined (DOUBLE_FP)\n"
"  double radius_sqr = radius * radius;\n"
"  #else\n"
"  float radius_sqr = radius * radius;\n"
"  #endif\n"
"*/\n"
"\n"
"  //int j = blockIdx.x * blockDim.x + threadIdx.x;\n"
"  int j = get_global_id(0);\n"
"\n"
"  if (j >= number_points) {\n"
"    // Not supported in OpenCL\n"
"    // return;\n"
"  }\n"
"  else {\n"
"    for (int i = 0; i < n; i++)\n"
"        {\n"
"	  float dx = points[i].x - points[j].x;\n"
"	  float dy = points[i].y - points[j].y;\n"
"	  float dz = points[i].z - points[j].z;\n"
"	  int array_index = i*n + j; //(((i-1) * i)/2) +j;\n"
"	  sqr_distances[array_index] = ((dx*dx + dy*dy + dz*dz) <= radius_sqr );\n"
"        }\n"
"  }\n"
"}\n"
"\n"
"/** \n"
"    own radiusSearch, just goes linear through the array of distances\n"
"    returns number of found points\n"
"\n"
"    Performs multiple searches in parallel, for all points belonging to point_index\n"
"    In indices each value is set to 1 in case it is result of the search, 0 otherwise\n"
"*/\n"
"    \n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"parallelRadiusSearch(\n"
"__global const int*  restrict point_index,\n"
"__global       bool* restrict indices, \n"
"__global const bool* restrict sqr_distances, \n"
"int start_index, \n"
"int search_points, \n"
"int cloud_size)\n"
"{\n"
"\n"
"    //int id = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    int id = get_global_id(0);\n"
"\n"
"    if (id >= cloud_size) {\n"
"      // Not supported in OpenCL\n"
"      //return;\n"
"    }\n"
"    else {\n"
"      bool found = false;\n"
"      bool is_skipped = false;\n"
"      for (int search_point_index = start_index; search_point_index < search_points; search_point_index++)\n"
"        {\n"
"	  if (id == point_index[search_point_index])\n"
"	    {\n"
"	      found = true;\n"
"              // Not supported in OpenCL \n"
"	      //continue;\n"
"              is_skipped = true;\n"
"	    }\n"
"          else {\n"
"            is_skipped = false;\n"
"          }\n"
"\n"
"          if (is_skipped == false) {\n"
"	    int array_index = point_index[search_point_index] * cloud_size+id;;\n"
"	    if ( sqr_distances[array_index])\n"
"	      found = true;\n"
"          }\n"
"        }\n"
"      indices[id] = found;\n"
"    }\n"
"}\n"
"\n"
"\n"
;
#endif // End of STRINGIFY_H
