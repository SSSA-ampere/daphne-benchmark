#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"/**\n"
"Find min/max\n"
"Whole range (from which a min/max is to be found) is distributed among work-groups.\n"
"Similarly, the work-group range is distributed amoung its work-items.\n"
"\n"
"https://stackoverflow.com/questions/24267280/efficiently-find-minimum-of-large-array-using-opencl\n"
"*/\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"// 3d euclidean point with intensity\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"// Location of min/max within the entire range isn't relevant.\n"
"// Only min/max values matters.\n"
"// Then just use PointXYZI struct and remove loc from the kernel\n"
"/*\n"
"typedef struct {\n"
"    float data[4];\n"
"    int   loc;\n"
"} PointXYZIOut;\n"
"*/\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"           __global const PointXYZI* restrict input,       // host: target_\n"
"                          int                 input_size,  // host: target_->size()\n"
"           __global       PointXYZI* restrict gmins,       // each location stores the min of each wg\n"
"           __global       PointXYZI* restrict gmaxs        // each location stores the max of each wg\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid   = get_global_id(0);\n"
"    int lid   = get_local_id(0);\n"
"    int wgid  = get_group_id(0);\n"
"    int lsize = get_local_size(0);\n"
"\n"
"    // Storing min/max values and in local memory\n"
"    __local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"    __local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"    // Storing min/max private variables\n"
"    float mymin [3];\n"
"    float mymax [3];\n"
"\n"
"    // Initializing min/max values of local and private variables\n"
"    for (char n = 0; n < 3; n++) {\n"
"        lmins [lid].data[n] = INFINITY;\n"
"        lmaxs [lid].data[n] = - INFINITY;\n"
"        mymin[n] = INFINITY;\n"
"        mymax[n] = -INFINITY;\n"
"    }\n"
"    \n"
"    // # work-groups that execute this kernel\n"
"    int num_wg = get_num_groups(0); \n"
"\n"
"    // # elements (from which a min/max will be found) assigned to each work-group\n"
"    int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"    // Offsets \n"
"    int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"    int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"    // Iteration upper-bound for each wg\n"
"    int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"/*\n"
"    if (lid == 0) {\n"
"        printf(\"lid: %i | wgid: %i | #wg: %i | #elems_per_wg: %i | offset_wg: %i | offset_wi: %i | ubound: %i\\n\", lid, wgid, num_wg, num_elems_per_wg, offset_wg, offset_wi, upper_bound);\n"
"    }\n"
"*/\n"
"  \n"
"    // Finding min/max\n"
"    // The offset is different for each lid leading to sequential memory access\n"
"    // Understood that consecutive global memory locations are accesses in this fashion:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi1 | wi2 | wi3 | ... | wi0 | wi1   | wi2   | ... |\n"
"    //\n"
"    // And not that consecutive global memory locations are read by a single work-item:\n"
"    // | gm0 | gm1 | gm2 | gm3 | ... | gmX | gmX+1 | gmX+2 | ... |\n"
"    // | wi0 | wi0 | wi0 | wi0 | ... | wi1 | wi1   | wi1   | ... |\n"
"    PointXYZI temp;\n"
"    if (offset_wi < input_size) {\n"
"        for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"            temp = input [i];\n"
"	    for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"		   mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"		   mymax[n] = temp.data[n];\n"
"		}\n"
"            }\n"
"        }\n"
"        \n"
"        // Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"            lmins[lid].data[n] = mymin[n];\n"
"	    lmaxs[lid].data[n] = mymax[n];\n"
"        }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"// Disabling enclosing if-statement is OK because\n"
"// additionally-evaluated work-items do not affect functional correctness.\n"
"// This is achieved by the appropriate initialization \n"
"// to either INFINITY for mins, or -INFINITY for maxs.\n"
"//    if (offset_wi < input_size) {\n"
"        // Finding the work-group min/max (reduces global memory accesses)\n"
"        lsize = lsize >> 1; // divided size by 2\n"
"        while (lsize > 0) {\n"
"            if (lid < lsize) {\n"
"                for (char n = 0; n < 3; n++) {\n"
"                    if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"		        lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"		    }\n"
"\n"
"                    if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"		        lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"		    }\n"
"                }\n"
"            }\n"
"            lsize = lsize >> 1;\n"
"	    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"//    }\n"
"\n"
"    // Writing work-group minimum/maximum to global memory\n"
"    if (lid == 0) {\n"
"        gmins [wgid] = lmins[0];\n"
"        gmaxs [wgid] = lmaxs[0];\n"
"    }\n"
"\n"
"}\n"
"/**\n"
"Init targetcells elements\n"
"*/\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"  #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"// Copied from ndt_mapping/datatypes.h\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"// typedef std::vector<TargetGridLeafConstPtr> VoxelGrid;\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"    int numberPoints;\n"
"    /*\n"
"    int voxel_x;\n"
"    int voxel_y;\n"
"    int voxel_z;\n"
"    */\n"
"} TargetGridLeadConstPtr;\n"
"\n"
"// Using local memory: GPU utilization 20%\n"
"\n"
"// Using only private memory: GPU utilization 100%\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"                __global       TargetGridLeadConstPtr* restrict targetcells,\n"
"                               int                              targetcells_size\n"
"               )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"        /*\n"
"        TargetGridLeadConstPtr temp;\n"
"\n"
"        temp.numberPoints = 0;\n"
"        temp.mean[0] = 0;\n"
"        temp.mean[1] = 0;\n"
"        temp.mean[2] = 0;\n"
"	\n"
"        for (int i=0;i<3;i++) {\n"
"	    //temp.mean[i] = 0;\n"
"\n"
"            for (int j=0;j<3;j++) {\n"
"                temp.invCovariance.data[i][j] = 0.0;\n"
"            }\n"
"        }\n"
"\n"
"        temp.invCovariance.data[2][0] = 1.0;\n"
"        temp.invCovariance.data[1][1] = 1.0;\n"
"        temp.invCovariance.data[0][2] = 1.0;\n"
"        */\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	TargetGridLeadConstPtr temp = {\n"
"		{{{0.0, 0.0, 1.0},\n"
"		{0.0, 1.0, 0.0},\n"
"		{1.0, 0.0, 0.0}}},\n"
"		 \n"
"		{0.0, 0.0, 0.0}, \n"
"		0\n"
"	};\n"
"        #else\n"
"	TargetGridLeadConstPtr temp = {{0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, 0 /*, 0, 0, 0*/};\n"
"        #endif\n"
"\n"
"        // Copying local contents into global memory\n"
"        targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
"Calculate firstPass\n"
"*/\n"
"\n"
"// Atomic addition of doubles requires extension\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"// Only atom_cmpxchg() works on doubles. This link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"\n"
"// Remember that 64-bit flavors have different names than 32-bit ones (atom_<> rather than atomic_<>)\n"
"// https://community.amd.com/thread/230784\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atom_cmpxchg.html\n"
"// https://www.khronos.org/registry/OpenCL/sdk/2.0/docs/man/xhtml/atomic_cmpxchg.html\n"
"void atomicAdd_global_double(volatile __global double *addr, double val)\n"
"{\n"
"	union{\n"
"		ulong u64;\n"
"		double d64;\n"
"	} next, expected, current;\n"
"\n"
"	current.d64 = *addr;\n"
"\n"
"	do{\n"
"		expected.d64 = current.d64;\n"
"		next.d64 = expected.d64 + val;\n"
"		current.u64 = atom_cmpxchg( (volatile __global ulong *)addr, expected.u64, next.u64);\n"
"	} while( current.u64 != expected.u64 );\n"
"}\n"
"#else\n"
"void atomicAdd_global_singleFP(volatile __global float *addr, float val)\n"
"{\n"
"	union{\n"
"		uint u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __global uint *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"#endif\n"
"\n"
"inline int linearizeAddr(\n"
"                         const int x, const int y, const int z,\n"
"                         const int voxelDimension_0, const int voxelDimension_1\n"
"                        )\n"
"{\n"
"    return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"\n"
"inline int linearizeCoord(\n"
"                          const float x, const float y, const float z, \n"
"                          const PointXYZI minVoxel,\n"
"			  const float     inv_resolution,\n"
"                          const int       voxelDimension_0, const int       voxelDimension_1\n"
"			 )\n"
"{\n"
"    int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"    int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"    int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"\n"
"    return linearizeAddr( \n"
"                         idx_x, idx_y, idx_z,\n"
"                         voxelDimension_0, voxelDimension_1\n"
"                        );\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	  __global const PointXYZI*              restrict input,       // host: target_\n"
"                         int                              input_size,  // host: target_->size()\n"
"	  __global       TargetGridLeadConstPtr* restrict targetcells, // host: target_cells_\n"
"                         int                              targetcells_size,  // host: target_cells->size()\n"
"                         PointXYZI                        minVoxel,\n"
"                         float                            inv_resolution,\n"
"	                 int                              voxelDimension_0,\n"
"	                 int                              voxelDimension_1\n"
"         )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < input_size) {\n"
"\n"
"        // Each work-item gets a different input target_ data element from global memory\n"
"        PointXYZI temp_target = input [gid];\n"
"\n"
"        // Getting voxelIndex value carried by each work-item\n"
"        int voxelIndex = linearizeCoord (\n"
"                                         temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"                                         minVoxel,\n"
"                                         inv_resolution,\n"
"                                         voxelDimension_0, voxelDimension_1\n"
"                                        );\n"
"/*\n"
"	// Added to detect wrong accesses (i.e. beyond boundaries)\n"
"	if (voxelIndex >= targetcells_size) {\n"
"            printf(\"gid: %i, voxelIndex: %i, targetcells_size: %i -> ERROR\\n\", gid, voxelIndex, targetcells_size);\n"
"	}\n"
"*/\n"
"\n"
"        // Reducing atomically\n"
"/*\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[0], temp_target.data[0]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[1], temp_target.data[1]);\n"
"        atomicAdd_global_double(&targetcells[voxelIndex].mean[2], temp_target.data[2]);\n"
"*/\n"
"/*\n"
"	for (int k=0; k<3; k++) {\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[k], temp_target.data[k]);\n"
"	}\n"
"*/\n"
"\n"
"        atomic_inc             (&targetcells[voxelIndex].numberPoints);\n"
"\n"
"        // Calculating covariance atomically\n"
"        for (char row = 0; row < 3; row ++) {\n"
"            #if defined (DOUBLE_FP)\n"
"            atomicAdd_global_double(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #else\n"
"            atomicAdd_global_singleFP(&targetcells[voxelIndex].mean[row], temp_target.data[row]);\n"
"            #endif\n"
"\n"
"            for (char col = 0; col < 3; col ++) {\n"
"                #if defined (DOUBLE_FP)\n"
"	        atomicAdd_global_double(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #else\n"
"	        atomicAdd_global_singleFP(&targetcells[voxelIndex].invCovariance.data[row][col], temp_target.data[row] * temp_target.data[col]);\n"
"                #endif\n"
"            }\n"
"        }\n"
"\n"
"    }\n"
"} \n"
"// invert matrix: its just 3x3 so we use the determinant\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"    Mat33 temp;\n"
"\n"
"    #if defined (DOUBLE_FP)\n"
"    double det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    double invDet = 1.0 / det;\n"
"    #else\n"
"    float det = m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"	         m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"	         m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"\n"
"    float invDet = 1.0f / det;\n"
"    #endif\n"
"\n"
"    // adjungated matrix of minors\n"
"    temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"    temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"    temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"    temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"    temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"    temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"    temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"    temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"    temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"    for (char row = 0; row < 3; row++)\n"
"	for (char col = 0; col < 3; col++)\n"
"	    m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	   __global       TargetGridLeadConstPtr* restrict targetcells,                // host: target_cells_\n"
"                          int                              targetcells_size,           // host: target_cells_.size()\n"
"			  int                              targetcells_size_minus_1\n"
"          )\n"
"{\n"
"    // Indices\n"
"    int gid = get_global_id(0);\n"
"\n"
"    if (gid < targetcells_size) {\n"
"\n"
"        // Temporal targetcell value stored in private memory\n"
"        TargetGridLeadConstPtr temp_tc = targetcells[gid];\n"
"\n"
"/*\n"
"        // If not enough points it canot accuratly approximated using a normal distribution\n"
"        Vec3 pointSum = {temp_tc.mean[0], temp_tc.mean[1], temp_tc.mean[2]};\n"
"\n"
"        temp_tc.mean[0] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[1] /= temp_tc.numberPoints;\n"
"        temp_tc.mean[2] /= temp_tc.numberPoints;\n"
"*/\n"
"\n"
"        Vec3 pointSum;\n"
"\n"
"        for (char k = 0; k < 3; k++) {\n"
"            pointSum[k] = temp_tc.mean[k];\n"
"            temp_tc.mean[k] /= temp_tc.numberPoints;\n"
"        }\n"
"\n"
"        #if defined (DOUBLE_FP)\n"
"	double tmp;\n"
"        #else\n"
"        float tmp;\n"
"        #endif\n"
"\n"
"        for (char row = 0; row < 3; row++) {\n"
"            for (char col = 0; col < 3; col++) {\n"
"	        tmp = (temp_tc.invCovariance.data[row][col] - 2 * (pointSum[row] * temp_tc.mean[col])) / targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"                temp_tc.invCovariance.data[row][col] = tmp * (targetcells_size_minus_1) / temp_tc.numberPoints; \n"
"            }\n"
"        }\n"
"\n"
"        invertMatrix(&temp_tc.invCovariance);\n"
"\n"
"        // Copying temp_tc into global memory\n"
"        targetcells[gid] = temp_tc;\n"
"\n"
"    }\n"
"}\n"
;
#endif // End of STRINGIFY_H
