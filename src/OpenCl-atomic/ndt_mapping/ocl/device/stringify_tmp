
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *all_ocl_krnl =
"\n"
"typedef struct {\n"
"    float data[4];\n"
"} PointXYZI;\n"
"\n"
"typedef struct {\n"
"	float x;\n"
"	float y;\n"
"	float z;\n"
"	int iNext;\n"
"} PointQueue;\n"
"\n"
"/**\n"
" * Finds the point cloud extends for each work group.\n"
" * input: point cloud to measure\n"
" * input_size: number of cloud elements\n"
" * gmins: low bounds, one entry for each work group\n"
" * gmaxs: high bounds, one entry for each work group\n"
" */\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"findMinMax(\n"
"	__global const PointXYZI* restrict input,\n"
"	int input_size,\n"
"	__global PointXYZI* restrict gmins,\n"
"	__global PointXYZI* restrict gmaxs\n"
") {\n"
"	// Indices\n"
"	int gid   = get_global_id(0);\n"
"	int lid   = get_local_id(0);\n"
"	int wgid  = get_group_id(0);\n"
"	int lsize = get_local_size(0);\n"
"\n"
"	// Storing min/max values and in local memory\n"
"	__local PointXYZI lmins [NUMWORKITEMS_PER_WORKGROUP];\n"
"	__local PointXYZI lmaxs [NUMWORKITEMS_PER_WORKGROUP];\n"
"\n"
"	// Storing min/max private variables\n"
"	float mymin [3];\n"
"	float mymax [3];\n"
"\n"
"	// Initializing min/max values of local and private variables\n"
"	for (char n = 0; n < 3; n++) {\n"
"		lmins [lid].data[n] = INFINITY;\n"
"		lmaxs [lid].data[n] = - INFINITY;\n"
"		mymin[n] = INFINITY;\n"
"		mymax[n] = -INFINITY;\n"
"	}\n"
"\n"
"	// # work-groups that execute this kernel\n"
"	int num_wg = get_num_groups(0); \n"
"\n"
"	// # elements (from which a min/max will be found) assigned to each work-group\n"
"	int num_elems_per_wg = /*input_size / num_wg*/ lsize;\n"
"\n"
"	// Offsets \n"
"	int offset_wg = num_elems_per_wg * wgid; // of each work-group\n"
"	int offset_wi = offset_wg + lid;         // of each work-item within a work-group\n"
"\n"
"	// Iteration upper-bound for each wg\n"
"	int upper_bound = num_elems_per_wg * (wgid + 1);\n"
"\n"
"	PointXYZI temp;\n"
"	if (offset_wi < input_size) {\n"
"		for (int i = offset_wi; i < upper_bound; i += lsize) {\n"
"			temp = input [i];\n"
"		for (char n = 0; n < 3; n++) {\n"
"		if (temp.data[n] < mymin[n]) {\n"
"			mymin[n] = temp.data[n];\n"
"		}\n"
"\n"
"		if (temp.data[n] > mymax[n]) {\n"
"			mymax[n] = temp.data[n];\n"
"		}\n"
"			}\n"
"		}\n"
"		\n"
"		// Storing the min/max found by each work-item in local memory\n"
"	for (char n = 0; n < 3; n++) {\n"
"		lmins[lid].data[n] = mymin[n];\n"
"		lmaxs[lid].data[n] = mymax[n];\n"
"		}\n"
"	}\n"
"	// wait for the writes of work group scale to finish\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	// Finding the work-group min/max locally\n"
"	lsize = lsize >> 1; // binary reduction\n"
"	while (lsize > 0) {\n"
"		if (lid < lsize) {\n"
"			for (char n = 0; n < 3; n++) {\n"
"				if (lmins[lid].data[n] > lmins[lid+lsize].data[n]) {\n"
"					lmins[lid].data[n] = lmins[lid+lsize].data[n];\n"
"				}\n"
"				if (lmaxs[lid].data[n] < lmaxs[lid+lsize].data[n]) {\n"
"					lmaxs[lid].data[n] = lmaxs[lid+lsize].data[n];\n"
"				}\n"
"			}\n"
"		}\n"
"		lsize = lsize >> 1; // binary reduction\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"	// Writing work-group minimum/maximum to global memory\n"
"	if (lid == 0) {\n"
"		gmins [wgid] = lmins[0];\n"
"		gmaxs [wgid] = lmaxs[0];\n"
"	}\n"
"}\n"
"#if defined (DOUBLE_FP)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"typedef struct {\n"
"  #if defined (DOUBLE_FP)\n"
"  double data[3][3];\n"
"  #else\n"
"  float data[3][3];\n"
"  #endif\n"
"} Mat33;\n"
"\n"
"#if defined (DOUBLE_FP)\n"
"typedef double Vec3[3];\n"
"#else\n"
"typedef float Vec3[3];\n"
"#endif\n"
"\n"
"typedef struct {\n"
"    Mat33 invCovariance;\n"
"    Vec3 mean;\n"
"	int first;\n"
"} Voxel;\n"
"\n"
"/**\n"
" * Initializes a voxel grid.\n"
" * targetcells: voxel grid\n"
" * targetcells_size: number of cells in the voxel grid\n"
" */\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"initTargetCells(\n"
"	__global Voxel* restrict targetcells,\n"
"	int targetcells_size)\n"
"{\n"
"    int gid = get_global_id(0);\n"
"	if (gid < targetcells_size) {\n"
"		#if defined (DOUBLE_FP)\n"
"		Voxel temp = {\n"
"			{{\n"
"				{0.0, 0.0, 1.0},\n"
"				{0.0, 1.0, 0.0},\n"
"				{1.0, 0.0, 0.0}\n"
"			}},\n"
"			{0.0, 0.0, 0.0}, \n"
"			-1\n"
"		};\n"
"		#else\n"
"		Voxel temp = {\n"
"			{{\n"
"				{0.0f, 0.0f, 1.0f},\n"
"				{0.0f, 1.0f, 0.0f},\n"
"				{1.0f, 0.0f, 0.0f}\n"
"			}}, \n"
"			{0.0f, 0.0f, 0.0f}, \n"
"			-1\n"
"		};\n"
"		#endif\n"
"		targetcells[gid] = temp;\n"
"    }\n"
"}\n"
"/**\n"
" * Reduces a multi dimensional voxel index to one dimension.\n"
" */\n"
"inline int linearizeAddr(\n"
"	const int x, const int y, const int z,\n"
"	const int voxelDimension_0, const int voxelDimension_1)\n"
"{\n"
"	return  (x + voxelDimension_0 * (y + voxelDimension_1 * z));\n"
"}\n"
"/**\n"
" * Reduces a continuous, multi dimensional coordinate inside a voxel grid to one dimension.\n"
" */\n"
"inline int linearizeCoord(\n"
"	const float x, const float y, const float z, const PointXYZI minVoxel,\n"
"	const float inv_resolution, const int voxelDimension_0, const int voxelDimension_1)\n"
"{\n"
"	int idx_x = (x - minVoxel.data[0]) * inv_resolution;\n"
"	int idx_y = (y - minVoxel.data[1]) * inv_resolution;\n"
"	int idx_z = (z - minVoxel.data[2]) * inv_resolution;\n"
"	return linearizeAddr(idx_x, idx_y, idx_z, voxelDimension_0, voxelDimension_1);\n"
"}\n"
"\n"
"/**\n"
" * Assigns each point to its cell in a voxel grid.\n"
" * input: point cloud\n"
" * input_size: number of points in the cloud\n"
" * targetcells: voxel grid\n"
" * targetcells_size: number of cells in the voxel grid\n"
" * minVoxel: voxel grid starting coordinates\n"
" * inv_resolution: inverted cell distance\n"
" * voxelDimension: multi dimensional voxel grid size\n"
" */\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"firstPass(\n"
"	__global PointXYZI* restrict input,\n"
"	int input_size,\n"
"	__global Voxel* restrict targetcells,\n"
"	int targetcells_size,\n"
"	PointXYZI minVoxel,\n"
"	float inv_resolution,\n"
"	int voxelDimension_0,\n"
"	int voxelDimension_1)\n"
"{\n"
"	// Indices\n"
"	int gid = get_global_id(0);\n"
"	if (gid < input_size) {\n"
"		// Each work-item gets a different input target_ data element from global memory\n"
"		PointXYZI temp_target = input[gid];\n"
"		// index of the cell the point belongs to\n"
"		int voxelIndex = linearizeCoord (\n"
"			temp_target.data[0], temp_target.data[1], temp_target.data[2],\n"
"			minVoxel,\n"
"			inv_resolution,\n"
"			voxelDimension_0, voxelDimension_1\n"
"		);\n"
"		// append point to queue front\n"
"		int next = atomic_xchg(&targetcells[voxelIndex].first, gid);\n"
"		// write next element to last vector component (int bits written to float datum)\n"
"		input[gid].data[3] = *((float*)&next);\n"
"	}\n"
"} \n"
"/**\n"
" * Simple matrix inversion using the determinant\n"
" */\n"
"void invertMatrix(Mat33* m)\n"
"{\n"
"	Mat33 temp;\n"
"	#if defined (DOUBLE_FP)\n"
"	double det = \n"
"		m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"		m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"		m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"	double invDet = 1.0 / det;\n"
"	#else\n"
"	float det = \n"
"		m->data[0][0] * (m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2]) -\n"
"		m->data[1][0] * (m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]) +\n"
"		m->data[2][0] * (m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2]);\n"
"	float invDet = 1.0f / det;\n"
"	#endif\n"
"\n"
"	// adjungated matrix of minors\n"
"	temp.data[0][0] = m->data[2][2] * m->data[1][1] - m->data[2][1] * m->data[1][2];\n"
"	temp.data[0][1] = -( m->data[2][2] * m->data[0][1] - m->data[2][1] * m->data[0][2]);\n"
"	temp.data[0][2] = m->data[1][2] * m->data[0][1] - m->data[1][1] * m->data[0][2];\n"
"\n"
"	temp.data[1][0] = -( m->data[2][2] * m->data[0][1] - m->data[2][0] * m->data[1][2]);\n"
"	temp.data[1][1] = m->data[2][2] * m->data[0][0] - m->data[2][1] * m->data[0][2];\n"
"	temp.data[1][2] = -( m->data[1][2] * m->data[0][0] - m->data[1][0] * m->data[0][2]);\n"
"\n"
"	temp.data[2][0] = m->data[2][1] * m->data[1][0] - m->data[2][0] * m->data[1][1];\n"
"	temp.data[2][1] = -( m->data[2][1] * m->data[0][0] - m->data[2][0] * m->data[0][1]);\n"
"	temp.data[2][2] = m->data[1][1] * m->data[0][0] - m->data[1][0] * m->data[0][1];\n"
"\n"
"	for (char row = 0; row < 3; row++)\n"
"		for (char col = 0; col < 3; col++)\n"
"			m->data[row][col] = temp.data[row][col] * invDet;\n"
"}\n"
"/**\n"
" * Normalizes a voxel grid after point assignment.\n"
" * targetcells: voxel grid\n"
" * targetcells_size: number of cells in the voxel grid\n"
" * targetcells_size_minus_1: modified number of cells in the voxel grid\n"
" */\n"
"__kernel\n"
"void __attribute__ ((reqd_work_group_size(NUMWORKITEMS_PER_WORKGROUP,1,1)))\n"
"secondPass(\n"
"	__global Voxel* restrict targetcells,\n"
"	__global const PointXYZI* input,\n"
"	int targetcells_size,\n"
"	int targetcells_size_minus_1)\n"
"{\n"
"	int gid = get_global_id(0);\n"
"	if (gid < targetcells_size) {\n"
"		Voxel temp_tc = targetcells[gid];\n"
"		int pointNo = 0;\n"
"		int iNext = temp_tc.first;\n"
"		while (iNext > -1) {\n"
"			PointXYZI temp_target = input[iNext];\n"
"			for (char row = 0; row < 3; row ++) {\n"
"				temp_tc.mean[row] += temp_target.data[row];\n"
"				for (char col = 0; col < 3; col ++) {\n"
"					temp_tc.invCovariance.data[row][col] += temp_target.data[row]*temp_target.data[col];\n"
"				}\n"
"			}\n"
"			// next queue item, interpret last component as int\n"
"			iNext = *((int*)&temp_target.data[3]);\n"
"			pointNo += 1;\n"
" 		}\n"
"\n"
"		Vec3 pointSum;\n"
"		for (char k = 0; k < 3; k++) {\n"
"			pointSum[k] = temp_tc.mean[k];\n"
"			temp_tc.mean[k] /= pointNo;\n"
"		}\n"
"		#if defined (DOUBLE_FP)\n"
"		double tmp;\n"
"		#else\n"
"		float tmp;\n"
"		#endif\n"
"		for (char row = 0; row < 3; row++) {\n"
"			for (char col = 0; col < 3; col++) {\n"
"				tmp = (temp_tc.invCovariance.data[row][col] - 2 * \n"
"					(pointSum[row] * temp_tc.mean[col])) \n"
"					/ targetcells_size + temp_tc.mean[row]*temp_tc.mean[col];\n"
"				temp_tc.invCovariance.data[row][col] = \n"
"					tmp * (targetcells_size_minus_1) / pointNo;\n"
"			}\n"
"		}\n"
"		invertMatrix(&temp_tc.invCovariance);\n"
"		targetcells[gid] = temp_tc;\n"
"	}\n"
"}\n"
;
#endif // End of STRINGIFY_H
