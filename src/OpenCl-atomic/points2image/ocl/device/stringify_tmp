
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *points2image_ocl_krnl =
"// points2image OpenCL kernel\n"
"typedef struct Mat44 {\n"
"  double data[4][4];\n"
"} Mat44;\n"
"\n"
"typedef struct Mat33 {\n"
"  double data[3][3];\n"
"} Mat33;\n"
"\n"
"typedef struct Mat13 {\n"
"  double data[3];\n"
"} Mat13;\n"
"\n"
"typedef struct Vec5 {\n"
"  double data[5];\n"
"} Vec5;\n"
"\n"
"typedef struct Point2d {\n"
"  double x;\n"
"  double y;\n"
"} Point2d;\n"
"\n"
"typedef struct ImageSize {\n"
"  int width;\n"
"  int height;\n"
"} ImageSize;\n"
"\n"
"\n"
"__kernel void pointcloud2_to_image(\n"
"	int          pointcloud2_height,\n"
"	int          pointcloud2_width,\n"
"	int          pointcloud2_point_step,\n"
"	__global const float*  restrict	pointcloud2_data,\n"
"	Mat44     cameraExtrinsicMat,\n"
"	Mat33     cameraMat,\n"
"	Vec5      distCoeff,\n"
"	ImageSize imageSize,\n"
"	__global       int*    restrict       Glob_pids,\n"
"	__global       float* restrict	Glob_pointdata2,\n"
"	__global       float* restrict   	Glob_intensity,\n"
"	__global       int*    restrict      	Glob_py,\n"
"	__global int* Glob_pid_no,\n"
"	__local int* Loc_pid_no,\n"
"	__local int* Loc_pid_start)\n"
"{\n"
"	// initialize local variables\n"
"	if (get_local_id(0) == 0 && get_local_id(1) == 0 && get_local_id(2) == 0) {\n"
"		*Loc_pid_no = 0;\n"
"		*Loc_pid_start = -1;\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	// Getting width and heights\n"
"	const int w          = imageSize.width;\n"
"	const int h          = imageSize.height;\n"
"	const int pc2_width  = pointcloud2_width;\n"
"	const int pc2_height = pointcloud2_height;\n"
"	const int pc2_pstep  = pointcloud2_point_step;\n"
"	\n"
"	// build transformation matrix\n"
"	Mat33 invR;\n"
"	Mat13 invT;\n"
"	for (int row = 0; row < 3; row++) {\n"
"		for (int col = 0; col < 3; col++) {\n"
"			invR.data[row][col] = cameraExtrinsicMat.data[col][row];\n"
"		}\n"
"		invT.data[row] = 0.0;\n"
"		for (int col = 0; col < 3; col++) {\n"
"			invT.data[row] -= invR.data[row][col] * cameraExtrinsicMat.data[col][3];\n"
"		}\n"
"	}\n"
"	// cloud data pointer\n"
"	__global const float* cp = (__global const float *)(pointcloud2_data);\n"
"\n"
"	// transformation for one point in the cloud\n"
"	const int y = 0;\n"
"	int x = (int)get_global_id(0);\n"
"	int px, py;\n"
"	float pointData;\n"
"	float intensity;\n"
"	int startIndex = -1;\n"
"	// discard the calculations for excess elements\n"
"	if (x < pc2_width) {\n"
"		int offset1 = (x + y*pc2_width) * pc2_pstep;\n"
"		intensity = cp[offset1/4 + 4];\n"
"		// apply the first transformation\n"
"		Mat13 point2 = {\n"
"			{\n"
"				cp[offset1/4 + 0],\n"
"				cp[offset1/4 + 1],\n"
"				cp[offset1/4 + 2]\n"
"			}\n"
"		};\n"
"\n"
"		Mat13 point;\n"
"		for (int row = 0; row < 3; row++) {\n"
"			point.data[row] = invT.data[row];\n"
"			for (int col = 0; col < 3; col++) \n"
"				point.data[row] += point2.data[col] * invR.data[row][col];\n"
"		}\n"
"		// discard elements with low depth after transformation\n"
"		if (point.data[2] <= 2.5) {\n"
"			//Glob_enable_pids [x] = 0; // disabled\n"
"		} else {\n"
"			// perspective division\n"
"			double tmpx = point.data[0] / point.data[2];\n"
"			double tmpy = point.data[1] / point.data[2];\n"
"			// apply the second transformation\n"
"			double r2 = tmpx * tmpx + tmpy * tmpy;\n"
"			double tmpdist = 1 + distCoeff.data[0] * r2\n"
"					+ distCoeff.data[1] * r2 * r2\n"
"					+ distCoeff.data[4] * r2 * r2 * r2;\n"
"			double imgx = tmpx * tmpdist\n"
"						+ 2 * distCoeff.data[2] * tmpx * tmpy\n"
"						+ distCoeff.data[3] * (r2 + 2 * tmpx * tmpx);\n"
"			double imgy = tmpy * tmpdist\n"
"						+ distCoeff.data[2] * (r2 + 2 * tmpy * tmpy)\n"
"						+ 2 * distCoeff.data[3] * tmpx * tmpy;\n"
"			// apply the third transformation\n"
"			px = (int)(cameraMat.data[0][0] * imgx + cameraMat.data[0][2] + 0.5);\n"
"			py = (int)(cameraMat.data[1][1] * imgy + cameraMat.data[1][2] + 0.5);\n"
"			// output points inside image bounds\n"
"			if( (0 <= px) && (px < w) && (0 <= py) && (py < h) ) {\n"
"				startIndex = atomic_inc(Loc_pid_no);\n"
"				pointData = point.data[2];\n"
"			}\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if (get_local_id(0) == 0 && get_local_id(1) == 0 && get_local_id(2) == 0) {\n"
"		if (*Loc_pid_no > 0) {\n"
"			*Loc_pid_start = atomic_add(Glob_pid_no, *Loc_pid_no);\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if (startIndex > -1) {\n"
"		int pid = py*w + px;\n"
"		int iResult = *Loc_pid_start + startIndex;\n"
"		Glob_pids[iResult] = pid;\n"
"		Glob_pointdata2[iResult] = pointData;\n"
"		Glob_intensity[iResult] = intensity;\n"
"		Glob_py[iResult] = py;\n"
"	}\n"
"}\n"
"\n"
;
#endif // End of STRINGIFY_H
